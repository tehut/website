---
layout: blog
title: " Cluster Level Logging with Kubernetes "
date:  Friday, June 11, 2015 

---
  

A Kubernetes cluster will typically be humming along running many system and application pods. How does the system administrator collect, manage and query the logs of the system pods? How does a user query the logs of their application which is composed of many pods which may be restarted or automatically generated by the Kubernetes system? These questions are addressed by the Kubernetes cluster level logging services.
  

Cluster level logging for Kubernetes allows us to collect logs which persist beyond the lifetime of the pod’s container images or the lifetime of the pod or even cluster. In this article we assume that a Kubernetes cluster has been created with cluster level logging support for sending logs to [Google Cloud Logging](https://cloud.google.com/logging/docs/). This is an option when creating a [Google Container Engine](https://cloud.google.com/container-engine/) (GKE) cluster, and is enabled by default for the open source [Google Compute Engine](https://cloud.google.com/compute/) (GCE) Kubernetes distribution. After a cluster has been created you will have a collection of system [pods](https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/pods.md) running that support monitoring, logging and DNS resolution for names of Kubernetes services:

  
$ kubectl get pods

NAME &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;READY &nbsp;&nbsp;&nbsp;&nbsp;REASON &nbsp;&nbsp;&nbsp;RESTARTS &nbsp;&nbsp;AGE

fluentd-cloud-logging-kubernetes-minion-0f64 &nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32m

fluentd-cloud-logging-kubernetes-minion-27gf &nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32m

fluentd-cloud-logging-kubernetes-minion-pk22 &nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31m

fluentd-cloud-logging-kubernetes-minion-20ej &nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31m

kube-dns-v3-pk22 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3/3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32m
  

monitoring-heapster-v1-20ej &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32m
  
Here is the same information in a picture which shows how the pods might be placed on specific nodes.
  

[![](https://1.bp.blogspot.com/-FSXnrHLDMJs/Vxfzx2rsreI/AAAAAAAAAbk/PaDTpksKEZk4e8YQff5-JhGPoEpgyWaHgCLcB/s400/cloud-logging.png)](https://1.bp.blogspot.com/-FSXnrHLDMJs/Vxfzx2rsreI/AAAAAAAAAbk/PaDTpksKEZk4e8YQff5-JhGPoEpgyWaHgCLcB/s1600/cloud-logging.png)
  

  

Here is a close up of what is running on each node.
  

[![](https://4.bp.blogspot.com/-T7kPtjq8O9A/Vxfz6k7XogI/AAAAAAAAAbo/-59dO6F58sERDOQGJ7872ex_KkEKFpArwCLcB/s400/0f64.png)](https://4.bp.blogspot.com/-T7kPtjq8O9A/Vxfz6k7XogI/AAAAAAAAAbo/-59dO6F58sERDOQGJ7872ex_KkEKFpArwCLcB/s1600/0f64.png)  

  

[![](https://3.bp.blogspot.com/-5VRLexsSJwA/Vxf0F0ccVDI/AAAAAAAAAbs/rh4KGFc95-cIdrTxAujYH2LMrCQ8vrdzQCLcB/s400/27gf.png)](https://3.bp.blogspot.com/-5VRLexsSJwA/Vxf0F0ccVDI/AAAAAAAAAbs/rh4KGFc95-cIdrTxAujYH2LMrCQ8vrdzQCLcB/s1600/27gf.png)  

  

[![](https://4.bp.blogspot.com/-UXOxauNy8FQ/Vxf0SaGujNI/AAAAAAAAAb0/Pnf6e_iiUfoKkooGyrF3Gmd8wh0vPrteQCLcB/s400/pk22.png)](https://4.bp.blogspot.com/-UXOxauNy8FQ/Vxf0SaGujNI/AAAAAAAAAb0/Pnf6e_iiUfoKkooGyrF3Gmd8wh0vPrteQCLcB/s1600/pk22.png)  

[![](https://2.bp.blogspot.com/-UgpwCx4BNwQ/Vxf0Wc8-HwI/AAAAAAAAAb4/g3D1bE74FQA2k9uwc9ZbZuB1N7MTU7swgCLcB/s400/20ej.png)](https://2.bp.blogspot.com/-UgpwCx4BNwQ/Vxf0Wc8-HwI/AAAAAAAAAb4/g3D1bE74FQA2k9uwc9ZbZuB1N7MTU7swgCLcB/s1600/20ej.png)
  

  

The first diagram shows four nodes created on a GCE cluster with the name of each VM node on a purple background. The internal and public IPs of each node are shown on gray boxes and the pods running in each node are shown in green boxes. Each pod box shows the name of the pod and the namespace it runs in, the IP address of the pod and the images which are run as part of the pod’s execution. Here we see that every node is running a fluentd-cloud-logging pod which is collecting the log output of the containers running on the same node and sending them to Google Cloud Logging. A pod which provides a [cluster DNS service](https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/dns.md) runs on one of the nodes and a pod which provides monitoring support runs on another node.
  

To help explain how cluster level logging works let’s start off with a synthetic log generator pod specification [counter-pod.yaml](https://github.com/GoogleCloudPlatform/kubernetes/blob/master/examples/blog-logging/counter-pod.yaml):
  

  

&nbsp; **apiVersion** : v1  
&nbsp; **kind** : Pod  
&nbsp; **metadata** :  
&nbsp; &nbsp; **name** : counter  
&nbsp; **spec** :  
&nbsp; &nbsp; **containers** :  
&nbsp; &nbsp;- **name** : count  
&nbsp; &nbsp; &nbsp; **image** : ubuntu:14.04  
&nbsp; &nbsp; &nbsp; **args** : [bash, -c,&nbsp;  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'for ((i = 0; ; i++)); do echo "$i: $(date)"; sleep 1; done']  

  

This pod specification has one container which runs a bash script when the container is born. This script simply writes out the value of a counter and the date once per second and runs indefinitely. Let’s create the pod.

  

$ kubectl create -f counter-pod.yaml
  

pods/counter
  

We can observe the running pod:

$ kubectl get pods

NAME &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;READY &nbsp;&nbsp;&nbsp;&nbsp;REASON &nbsp;&nbsp;&nbsp;RESTARTS &nbsp;&nbsp;AGE

counter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5m

fluentd-cloud-logging-kubernetes-minion-0f64 &nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;55m

fluentd-cloud-logging-kubernetes-minion-27gf &nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;55m

fluentd-cloud-logging-kubernetes-minion-pk22 &nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;55m

fluentd-cloud-logging-kubernetes-minion-20ej &nbsp;&nbsp;1/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;55m

kube-dns-v3-pk22 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3/3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;55m

monitoring-heapster-v1-20ej &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0/1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running &nbsp;&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;56m
  
  

This step may take a few minutes to download the ubuntu:14.04 image during which the pod status will be shown as Pending. 
  

One of the nodes is now running the counter pod:
  

[![](https://4.bp.blogspot.com/-BI3zOVlrHwA/Vxf0KwcqtCI/AAAAAAAAAbw/vzv8X8vQrso9Iycx4qQHuOslE8So7smLgCLcB/s400/27gf-counter.png)](https://4.bp.blogspot.com/-BI3zOVlrHwA/Vxf0KwcqtCI/AAAAAAAAAbw/vzv8X8vQrso9Iycx4qQHuOslE8So7smLgCLcB/s1600/27gf-counter.png)
  

  

When the pod status changes to Running we can use the kubectl logs command to view the output of this counter pod.
  

$ kubectl logs counter

0: Tue Jun &nbsp;2 21:37:31 UTC 2015

1: Tue Jun &nbsp;2 21:37:32 UTC 2015

2: Tue Jun &nbsp;2 21:37:33 UTC 2015

3: Tue Jun &nbsp;2 21:37:34 UTC 2015

4: Tue Jun &nbsp;2 21:37:35 UTC 2015

5: Tue Jun &nbsp;2 21:37:36 UTC 2015

...
  

This command fetches the log text from the Docker log file for the image that is running in this container. We can connect to the running container and observe the running counter bash script.
  

$ kubectl exec -i counter bash

ps aux

USER &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PID %CPU %MEM &nbsp;&nbsp;&nbsp;VSZ &nbsp;&nbsp;RSS TTY &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STAT START &nbsp;&nbsp;TIME COMMAND

root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;0.0 &nbsp;0.0 &nbsp;17976 &nbsp;2888 ? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ss &nbsp;&nbsp;00:02 &nbsp;&nbsp;0:00 bash -c for ((i = 0; ; i++)); do echo "$i: $(date)"; sleep 1; done

root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;468 &nbsp;0.0 &nbsp;0.0 &nbsp;17968 &nbsp;2904 ? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ss &nbsp;&nbsp;00:05 &nbsp;&nbsp;0:00 bash

root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;479 &nbsp;0.0 &nbsp;0.0 &nbsp;&nbsp;4348 &nbsp;&nbsp;812 ? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S &nbsp;&nbsp;&nbsp;00:05 &nbsp;&nbsp;0:00 sleep 1

root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;480 &nbsp;0.0 &nbsp;0.0 &nbsp;15572 &nbsp;2212 ? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R &nbsp;&nbsp;&nbsp;00:05 &nbsp;&nbsp;0:00 ps aux
  

What happens if for any reason the image in this pod is killed off and then restarted by Kubernetes? Will we still see the log lines from the previous invocation of the container followed by the log lines for the started container? Or will we lose the log lines from the original container’s execution and only see the log lines for the new container? Let’s find out. First let’s stop the currently running counter.
  

$ kubectl stop pod counter

pods/counter
  

Now let’s restart the counter.
  

$ kubectl create -f counter-pod.yaml

pods/counter
  

Let’s wait for the container to restart and get the log lines again.
  

$ kubectl logs counter

0: Tue Jun &nbsp;2 21:51:40 UTC 2015

1: Tue Jun &nbsp;2 21:51:41 UTC 2015

2: Tue Jun &nbsp;2 21:51:42 UTC 2015

3: Tue Jun &nbsp;2 21:51:43 UTC 2015

4: Tue Jun &nbsp;2 21:51:44 UTC 2015

5: Tue Jun &nbsp;2 21:51:45 UTC 2015

6: Tue Jun &nbsp;2 21:51:46 UTC 2015

7: Tue Jun &nbsp;2 21:51:47 UTC 2015

8: Tue Jun &nbsp;2 21:51:48 UTC 2015
  

Oh no! We’ve lost the log lines from the first invocation of the container in this pod! Ideally, we want to preserve all the log lines from each invocation of each container in the pod. Furthermore, even if the pod is restarted we would still like to preserve all the log lines that were ever emitted by the containers in the pod. But don’t fear, this is the functionality provided by cluster level logging in Kubernetes. When a cluster is created, the standard output and standard error output of each container can be ingested using a [Fluentd](http://www.fluentd.org/) agent running on each node into either [Google Cloud Logging](https://cloud.google.com/logging/docs/) or into Elasticsearch and viewed with Kibana. This blog article focuses on Google Cloud Logging.

  

When a Kubernetes cluster is created with logging to Google Cloud Logging enabled, the system creates a pod called fluentd-cloud-logging on each node of the cluster to collect Docker container logs. These pods were shown at the start of this blog article in the response to the first get pods command.
  

This log collection pod has a specification which looks something like this [fluentd-gcp.yaml](https://github.com/GoogleCloudPlatform/kubernetes/blob/master/cluster/saltbase/salt/fluentd-gcp/fluentd-gcp.yaml):
  

apiVersion: v1

kind: Pod

metadata:

 &nbsp;name: fluentd-cloud-logging

spec:

 &nbsp;containers:

 &nbsp;- name: fluentd-cloud-logging

 &nbsp;&nbsp;&nbsp;image: gcr.io/google\_containers/fluentd-gcp:1.6

 &nbsp;&nbsp;&nbsp;env:

 &nbsp;&nbsp;&nbsp;- name: FLUENTD\_ARGS

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: -qq

 &nbsp;&nbsp;&nbsp;volumeMounts:

 &nbsp;&nbsp;&nbsp;- name: containers

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mountPath: /var/lib/docker/containers

 &nbsp;volumes:

 &nbsp;- name: containers

 &nbsp;&nbsp;&nbsp;hostPath:

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path: /var/lib/docker/containers
  

This pod specification maps the the directory on the host containing the Docker log files, /var/lib/docker/containers, to a directory inside the container which has the same path. The pod runs one image, gcr.io/google\_containers/fluentd-gcp:1.6, which is configured to collect the Docker log files from the logs directory and ingest them into Google Cloud Logging. One instance of this pod runs on each node of the cluster. Kubernetes will notice if this pod fails and automatically restart it.
  

We can click on the Logs item under the Monitoring section of the Google Developer Console and select the logs for the counter container, which will be called kubernetes.counter\_default\_count. &nbsp;This identifies the name of the pod (counter), the namespace (default) and the name of the container (count) for which the log collection occurred. Using this name we can select just the logs for our counter container from the drop down menu:

  

_(image-counter-new-logs.png)_  

When we view the logs in the Developer Console we observe the logs for both invocations of the container.  
  
_(image-screenshot-2015-06-02)_
  

Note the first container counted to 108 and then it was terminated. When the next container image restarted the counting process resumed from 0. Similarly if we deleted the pod and restarted it we would capture the logs for all instances of the containers in the pod whenever the pod was running.  
  
  

Logs ingested into Google Cloud Logging may be exported to various other destinations including [Google Cloud Storage](https://cloud.google.com/storage/) buckets and [BigQuery](https://cloud.google.com/bigquery/). Use the Exports tab in the Cloud Logging console to specify where logs should be streamed to (or follow this link to the [settings tab](https://pantheon.corp.google.com/project/_/logs/settings)).
  
  

We could query the ingested logs from BigQuery using the SQL query which reports the counter log lines showing the newest lines first.
  
  

SELECT metadata.timestamp, structPayload.log FROM [mylogs.kubernetes\_counter\_default\_count\_20150611] ORDER BY metadata.timestamp DESC
  
  

Here is some sample output:
  
  
**_(image-bigquery-log-new.png)_**  
  

We could also fetch the logs from Google Cloud Storage buckets to our desktop or laptop and then search them locally. The following command fetches logs for the counter pod running in a cluster which is itself in a GCE project called myproject. Only logs for the date 2015-06-11 are fetched.  
  
  

$ gsutil -m cp -r gs://myproject/kubernetes.counter\_default\_count/2015/06/11 .
  
Now we can run queries over the ingested logs. The example below uses the[jq](http://stedolan.github.io/jq/) program to extract just the log lines.  
  
  

$ cat 21\:00\:00\_21\:59\:59\_S0.json | jq '.structPayload.log'

"0: Thu Jun 11 21:39:38 UTC 2015\n"

"1: Thu Jun 11 21:39:39 UTC 2015\n"

"2: Thu Jun 11 21:39:40 UTC 2015\n"

"3: Thu Jun 11 21:39:41 UTC 2015\n"

"4: Thu Jun 11 21:39:42 UTC 2015\n"

"5: Thu Jun 11 21:39:43 UTC 2015\n"

"6: Thu Jun 11 21:39:44 UTC 2015\n"

"7: Thu Jun 11 21:39:45 UTC 2015\n"
...  
  
This article has touched briefly on the underlying mechanisms that support gathering cluster level logs on a Kubernetes deployment. The approach here only works for gathering the standard output and standard error output of the processes running in the pod’s containers. To gather other logs that are stored in files one can use a sidecar container to gather the required files as described at the page [Collecting log files within containers with Fluentd and sending them to the Google Cloud Logging service](https://github.com/GoogleCloudPlatform/kubernetes/tree/master/contrib/logging/fluentd-sidecar-gcp).
